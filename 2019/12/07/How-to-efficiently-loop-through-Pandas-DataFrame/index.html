<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>How to efficiently loop through Pandas DataFrame | Wei's Sandbox</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script src="https://www.googletagmanager.com/gtag/js?id=UA-153165207-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-153165207-1');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">üåì</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 5.4.2"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">How to efficiently loop through Pandas DataFrame</h1><a id="logo" href="/.">Wei's Sandbox</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about-me/"><i class="fa fa-user"> About</i></a><a href="/friends/"><i class="fa fa-link"> Links</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">How to efficiently loop through Pandas DataFrame</h1><div class="post-meta">2019-12-07<span> | </span><span class="category"><a href="/categories/Tech/">Tech</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/12/07/How-to-efficiently-loop-through-Pandas-DataFrame/" href="/2019/12/07/How-to-efficiently-loop-through-Pandas-DataFrame/#disqus_thread"></a><div class="post-content"><p>If working with data is part of your daily job, you will likely run into situations where you realize you have to loop through a Pandas Dataframe and process each row. I recently find myself in this situation where I need to loop through each row of a large DataFrame, do some complex computation to each row, and  recreate a new DataFrame base on the computation results. Savvy data scientists know immediately that this is one of the bad situations to be in, as looping through pandas DataFrame can be cumbersome and time consuming.</p>
<p><img src="https://i.imgur.com/vvyLWqv.jpg" alt=""></p>
<span id="more"></span>

<p>However, in the event where you have no option other than to loop through a DataFrame by rows, what is the most efficeint way? Let‚Äôs look at the usual suspects:</p>
<ul>
<li>for loop with <code>.iloc</code></li>
<li>iterrows</li>
<li>itertuple</li>
<li>apply</li>
<li>python zip</li>
<li>pandas vectorization</li>
<li>numpy vectorization</li>
</ul>
<p>When I wrote my piece of code I had a vague sense that I should stay away from <code>iloc</code>, <code>iterrows</code> and try using pandas builtin functions or apply. But I ended up using <code>itertuples</code> because what I was trying to do is fairly complex and could not be written in the form that utilizes apply. It turned out that using itertuple did not satisfy my time constraint, so I Googled around and found the above list of candidates I could potentially try out. I decided to try each of them out and record my findings as well as the reason why some options are more efficient that others.</p>
<h1 id="Experiment-results-with-timeit"><a href="#Experiment-results-with-timeit" class="headerlink" title="Experiment results with %timeit"></a>Experiment results with %timeit</h1><p>To compair the performance of each apprach fairly, I implemented each approach in a Jupyter notebook, and used the magic <code>% timeit</code> function to measure the efficiency of each on a randomly generated DataFrame. For simplicity, each approach is trying to compute the sum of all elements of two of the columns of the DataFrame.</p>
<p>First let‚Äôs generate a DataFrame large enough with random integers</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">100000</span>, <span class="number">4</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>The DataFrame <code>df</code> has a shape of (100000, 4), where the first 5 rows look like</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    A   B   C   D</span><br><span class="line">0   7   7   9   3</span><br><span class="line">1   3   6   2   8</span><br><span class="line">2   5   5   0   6</span><br><span class="line">3   2   7   9   1</span><br><span class="line">4   4   3   3   7</span><br></pre></td></tr></table></figure>

<p>For the experiment I am using pandas 0.25.3.</p>
<h2 id="Standard-python-for-loop-with-iloc"><a href="#Standard-python-for-loop-with-iloc" class="headerlink" title="Standard python for loop with iloc"></a>Standard python for loop with iloc</h2><p>A very basic way to achieve what we want to do is to use a standard for loop, and retrieve value using DataFrame‚Äôs <code>iloc</code> method</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loop_with_for</span>(<span class="params">df</span>):</span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df)):</span><br><span class="line">        temp += df[<span class="string">&#x27;A&#x27;</span>].iloc[index] + df[<span class="string">&#x27;B&#x27;</span>].iloc[index]</span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>
<p>Check performance using timeit </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit loop_with_for(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.01 s ¬± 14.7 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each)</p>
</blockquote>
<p>Using Jupyter‚Äôs <code>prune</code> function we get a detailed analysis on number of function calls and time consumed on each step</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun -l <span class="number">4</span> loop_with_for(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       10200009 function calls (10000007 primitive calls) in 4.566 seconds</span><br><span class="line"></span><br><span class="line"> Ordered by: internal time</span><br><span class="line"> List reduced from 39 to 4 due to restriction &lt;4&gt;</span><br><span class="line"></span><br><span class="line"> ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line"> 200000    0.555    0.000    1.035    0.000 frame.py:2964(__getitem__)</span><br><span class="line"> 200000    0.460    0.000    2.966    0.000 indexing.py:2135(_getitem_axis)</span><br><span class="line">1200000    0.315    0.000    0.481    0.000 &#123;built-in method builtins.isinstance&#125;</span><br><span class="line">      1    0.272    0.272    4.565    4.565 &lt;ipython-input-3-4b96483d67ee&gt;:1(loop_with_for)</span><br></pre></td></tr></table></figure>

<p>Seems like with the for loop + iloc approach, most of the time is spent on accessing values of each cell of the DataFrame, and checking data type with python‚Äôs <code>isinstance</code> function. Let‚Äôs see if we can get some speed up if we switch to using one of the functions pandas provides.</p>
<h2 id="Using-pandas-iterrows-function"><a href="#Using-pandas-iterrows-function" class="headerlink" title="Using pandas iterrows function"></a>Using pandas iterrows function</h2><p>The pandas <code>iterrows</code> function returns a pandas Series for each row, with the down side of not preserving dtypes across rows.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loop_with_iterrows</span>(<span class="params">df</span>):</span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">         temp += row.A + row.B</span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>
<p>Check performance using timeit </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit loop_with_iterrows(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>9.14 s ¬± 59.2 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun -l <span class="number">4</span> loop_with_iterrows(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">       30000101 function calls (29500097 primitive calls) in 17.009 seconds</span><br><span class="line"></span><br><span class="line"> Ordered by: internal time</span><br><span class="line"> List reduced from 105 to 4 due to restriction &lt;4&gt;</span><br><span class="line"></span><br><span class="line"> ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">4900013    1.627    0.000    2.911    0.000 &#123;built-in method builtins.isinstance&#125;</span><br><span class="line">3100004    0.938    0.000    1.284    0.000 generic.py:7(_check)</span><br><span class="line"> 100000    0.669    0.000   12.594    0.000 series.py:197(__init__)</span><br><span class="line">4700006    0.649    0.000    0.975    0.000 &#123;built-in method builtins.getattr&#125;</span><br></pre></td></tr></table></figure>
<p>Surprisingly, the <code>iterrows</code> approach is almost 5 times slow than using standard for loop! The reason, suggested by the above log, is that <code>iterrows</code> spends a lot of time creating pandas Series object, which is known to incur a fair amount of overhead. And yet, the Series it created does not preserve dtypes across rows, which is why it is always recommended to use <code>itertuples</code> over <code>iterrows</code>, if you have to choose between one of them.</p>
<h2 id="Using-pandas-itertuples-function"><a href="#Using-pandas-itertuples-function" class="headerlink" title="Using pandas itertuples function"></a>Using pandas itertuples function</h2><p>The pandas <code>itertuples</code> function is similar to <code>iterrows</code>, except it returns a <code>namedtuple</code> for each row, and preserves dtypes across rows.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loop_with_itertuples</span>(<span class="params">df</span>):</span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> row_tuple <span class="keyword">in</span> df.itertuples():</span><br><span class="line">        temp += row_tuple.A + row_tuple.B</span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>
<p>Check performance using timeit </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit loop_with_itertuples(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>110 ms ¬± 7.42 ms per loop (mean ¬± std. dev. of 7 runs, 10 loops each)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun -l <span class="number">4</span> loop_with_itertuples(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         301143 function calls (301120 primitive calls) in 0.200 seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: internal time</span><br><span class="line">   List reduced from 110 to 4 due to restriction &lt;4&gt;</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">        1    0.126    0.126    0.200    0.200 &lt;ipython-input-14-30ae2d632868&gt;:13(loop_with_itertuples)</span><br><span class="line">   100000    0.037    0.000    0.072    0.000 __init__.py:403(_make)</span><br><span class="line">   100000    0.024    0.000    0.024    0.000 &#123;built-in method __new__ of type object at 0x10919df70&#125;</span><br><span class="line">100090/100068    0.011    0.000    0.011    0.000 &#123;built-in method builtins.len&#125;</span><br></pre></td></tr></table></figure>
<p>It is exciting that we are finally getting into miliseconds per loop now! <code>itertuples</code> saves the overhead of creating Series each row by creating <code>namedtuple</code> instead. This is efficient, yet we are still paying for overhead for creating namedtuple.</p>
<h2 id="Using-python-zip"><a href="#Using-python-zip" class="headerlink" title="Using python zip"></a>Using python zip</h2><p>There is another interesting way to loop through the DataFrame, which is to use the python <code>zip</code> function. The way it works is it takes a number of iterables, and makes an iterator that aggragates elements from each of the iterables. Since a column of a Pandas DataFrame is an iterable, we can utilize <code>zip</code> to produce a tuple for each row just like <code>itertuples</code>, without all the pandas overhead! Personally I find the approach using <code>zip</code> very clever and clean. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loop_with_zip</span>(<span class="params">df</span>):</span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(df[<span class="string">&#x27;A&#x27;</span>], df[<span class="string">&#x27;B&#x27;</span>]):</span><br><span class="line">        temp += a + b</span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure>
<p>Check performance using timeit </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit loop_with_zip(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>27.1 ms ¬± 2.81 ms per loop (mean ¬± std. dev. of 7 runs, 10 loops each)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun -l <span class="number">4</span> loop_with_zip(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      146 function calls in 0.049 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: internal time</span><br><span class="line">List reduced from 35 to 4 due to restriction &lt;4&gt;</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     1    0.049    0.049    0.049    0.049 &lt;ipython-input-14-30ae2d632868&gt;:19(loop_with_zip)</span><br><span class="line">     1    0.000    0.000    0.049    0.049 &#123;built-in method builtins.exec&#125;</span><br><span class="line">     2    0.000    0.000    0.000    0.000 frame.py:2964(__getitem__)</span><br><span class="line">     2    0.000    0.000    0.000    0.000 base.py:1185(__iter__)</span><br></pre></td></tr></table></figure>
<p>Now we are talking! We just saved about 4 times by using <code>zip</code>. The efficiency depends on the fact that we are not creating namedtuple for every row. <code>zip</code> simply returns an iterator of tuples.</p>
<h2 id="Using-pandas-apply-function"><a href="#Using-pandas-apply-function" class="headerlink" title="Using pandas apply function"></a>Using pandas apply function</h2><p>Of course we can always use the well-known pandas apply function, which is commonly used to do complex operations on DataFrame rows and columns.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">using_apply</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="keyword">return</span> df.apply(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;A&#x27;</span>] + x[<span class="string">&#x27;B&#x27;</span>], axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>Check performance using timeit </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit using_apply(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.6 s ¬± 587 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun -l <span class="number">4</span> using_apply(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      8401975 function calls (8001949 primitive calls) in 4.559 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: internal time</span><br><span class="line">List reduced from 215 to 4 due to restriction &lt;4&gt;</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">200000    0.506    0.000    2.942    0.000 base.py:4702(get_value)</span><br><span class="line">     1    0.342    0.342    4.556    4.556 &#123;pandas._libs.reduction.reduce&#125;</span><br><span class="line">400002    0.306    0.000    0.811    0.000 &#123;pandas._libs.lib.values_from_object&#125;</span><br><span class="line">200000    0.299    0.000    3.357    0.000 series.py:1068(__getitem__)</span><br></pre></td></tr></table></figure>
<p>We are seeing about the same performance as using standard loops. According to <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/38938318/why-apply-sometimes-isnt-faster-than-for-loop-in-pandas-dataframe">this stack overflow post</a>, apply is still doing row operations and creating Series, which explains why the function calls are mostly getting values from Series. This is surprising as I always thought apply is one of the more efficient functions if one needs to do row operations.</p>
<h2 id="Using-pandas-builtin-add-function"><a href="#Using-pandas-builtin-add-function" class="headerlink" title="Using pandas builtin add function"></a>Using pandas builtin add function</h2><p>If what we are actually doing is just adding two columns and computing total sum, using the pandas built-in add and sum function would have been the obvious way. Unfortunately many computations we do does not have a simple built-in operation in Pandas. But this approach gives us a good indicator of how efficient these Pandas built-in functions are in practice.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">using_pandas_builtin</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="keyword">return</span> (df[<span class="string">&#x27;A&#x27;</span>] + df[<span class="string">&#x27;B&#x27;</span>]).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>Check performance using timeit </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit using_pandas_builtin(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>567 ¬µs ¬± 81.4 ¬µs per loop (mean ¬± std. dev. of 7 runs, 1000 loops each)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun -l <span class="number">4</span> using_pandas_builtin(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      645 function calls (642 primitive calls) in 0.002 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: internal time</span><br><span class="line">List reduced from 141 to 4 due to restriction &lt;4&gt;</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     1    0.000    0.000    0.000    0.000 &#123;built-in method _operator.add&#125;</span><br><span class="line">     2    0.000    0.000    0.000    0.000 &#123;method &#x27;reduce&#x27; of &#x27;numpy.ufunc&#x27; objects&#125;</span><br><span class="line">   105    0.000    0.000    0.000    0.000 &#123;built-in method builtins.isinstance&#125;</span><br><span class="line">    51    0.000    0.000    0.000    0.000 generic.py:7(_check)</span><br></pre></td></tr></table></figure>
<p>Since pandas functions are highly optimized, it is expected to be very efficient. This also shows that if your complex operation can be broken down to a series of pandas builtin functions, then it might make more sense to go that route than trying to jam all the operations in a lambda function then use apply.</p>
<h2 id="Using-numpy-builtin-function"><a href="#Using-numpy-builtin-function" class="headerlink" title="Using numpy builtin function"></a>Using numpy builtin function</h2><p>And eventually, if you are really looking for efficiency and speed, always go to numpy. Here we convert each column into a numpy array, and does all the heavy lifting utilizing numpy‚Äôs builtin functionalities. It‚Äôs known to be more efficient than Pandas Dataframe operations.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">using_numpy_builtin</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="keyword">return</span> (df[<span class="string">&#x27;A&#x27;</span>].values + df[<span class="string">&#x27;B&#x27;</span>].values).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>Check performance using timeit </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit using_numpy_builtin(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>272 ¬µs ¬± 41.5 ¬µs per loop (mean ¬± std. dev. of 7 runs, 1000 loops each)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%prun -l <span class="number">4</span> using_numpy_builtin(df)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      37 function calls in 0.001 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: internal time</span><br><span class="line">List reduced from 21 to 4 due to restriction &lt;4&gt;</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">     1    0.000    0.000    0.001    0.001 &lt;ipython-input-14-30ae2d632868&gt;:31(using_numpy_builtin)</span><br><span class="line">     1    0.000    0.000    0.000    0.000 &#123;method &#x27;reduce&#x27; of &#x27;numpy.ufunc&#x27; objects&#125;</span><br><span class="line">     1    0.000    0.000    0.001    0.001 &#123;built-in method builtins.exec&#125;</span><br><span class="line">     2    0.000    0.000    0.000    0.000 frame.py:2964(__getitem__)</span><br></pre></td></tr></table></figure>
<p>And of course, the clear winner of this contest is the approach using numpy. </p>
<h2 id="What-about-DataFrame-with-different-size"><a href="#What-about-DataFrame-with-different-size" class="headerlink" title="What about DataFrame with different size"></a>What about DataFrame with different size</h2><p>Now we have a good understanding of the efficiency of each approach, a natural question to ask is: how large the DataFrame needs to be for us to start considering trying a more efficient approach? To answer that question, I ran an experiment on DataFrames with different sizes, from 1000 rows to 40000 rows. The results are summarized in the plot below.<br><img src="https://i.imgur.com/WEJs6pS.png" alt="comparison of different approachs on different size DataFrames" title="comparison of different approachs on different size DataFrames"><br>From the plot we can see that <code>iterrows</code> is the least efficient and computation time grows the fastest. Then on second tier we have the <code>apply</code> function and standard for loop, which have almost same performance. Then the most efficient approaches are pandas and numpy built-in functions, the performance of which are very consistent despite increasing number of rows. Close seconds are <code>zip</code> and <code>itertuples</code>, with <code>zip</code> approach slightly faster than <code>itertuples</code>. (numpy approach is not drawn on the plot due to its running time being miniscule.)</p>
<p>Here is a table with the performance details of the experiment.<br><img src="https://i.imgur.com/tUgpvxR.png" alt="Experiment results" title="experiment"><br>For simple operations like what we do here (adding two columns), the difference in performance starts to show once we get to 10000 rows-ish. For more complicated operations, it seems reasonable to start thinking efficiency once you get to about 5000 rows.</p>
<h1 id="Additional-Insights"><a href="#Additional-Insights" class="headerlink" title="Additional Insights"></a>Additional Insights</h1><h2 id="how-to-use-apply"><a href="#how-to-use-apply" class="headerlink" title="how to use apply"></a>how to use apply</h2><p>I noticed that there are different ways one can use the apply function in our context, and how we use them actually makes a difference in terms of performance. Let‚Äôs take a look.</p>
<p>For the sake of illustration, I modified the <code>using_apply</code> function from above to compute sum of all columns instead of just columns ‚ÄòA‚Äô and ‚ÄòB‚Äô.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">using_apply</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="keyword">return</span> df.apply(<span class="keyword">lambda</span> x: x[<span class="string">&#x27;A&#x27;</span>] + x[<span class="string">&#x27;B&#x27;</span>] + x[<span class="string">&#x27;C&#x27;</span>] + x[<span class="string">&#x27;D&#x27;</span>], axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">using_apply_unpack</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="keyword">return</span> df[[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]].apply(<span class="keyword">lambda</span> x: <span class="built_in">sum</span>([*x]), axis=<span class="number">1</span>).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<p>The main difference between the above two function is the way we access each column value. In <code>using_apply</code>, we does apply on each row, then access each column value separately, whereas in the other function, we only pass in the relevant columns, and unpack the row to get all columns at the same time. On first look, I did not think this would make a difference, and boy I was wrong. Running both function on a DataFrame of size (100000, 4) yields the following results.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit using_apply(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.05 s ¬± 502 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each)</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%timeit using_apply_unpack(df)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.81 s ¬± 27.3 ms per loop (mean ¬± std. dev. of 7 runs, 1 loop each)</p>
</blockquote>
<p>The difference it more than 2 times! We get some savings of accessing all columns by unpacking rather than accessing one by one. If you need to use apply, then bear in mind that these little details could give you a fair amount of efficiency boost!</p>
<h2 id="source-code-comparison"><a href="#source-code-comparison" class="headerlink" title="source code comparison"></a>source code comparison</h2><p>Sometimes, to figure out what is going on, it is helpful to look at the source codes. I included some of the source codes of the functions here for readers who are interested.</p>
<h3 id="iterrows"><a href="#iterrows" class="headerlink" title="iterrows"></a>iterrows</h3><p>For readers who are interested, this is the <a target="_blank" rel="noopener" href="https://github.com/pandas-dev/pandas/blob/v0.25.3/pandas/core/frame.py#L860">iterrows source code</a> for <code>iterrows</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">columns = self.columns</span><br><span class="line">klass = self._constructor_sliced</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(self.index, self.values):</span><br><span class="line">    s = klass(v, index=columns, name=k)</span><br><span class="line">    <span class="keyword">yield</span> k, s</span><br></pre></td></tr></table></figure>
<p>The <code>klass</code> object here is actually the Series class. And it is interesting to see that <code>iterrows</code> also uses <code>zip</code>, except it is using it to create Series by zipping index and values together. This partly explains why <code>zip</code> beats <code>iterrows</code> by so much.</p>
<h3 id="itertuples"><a href="#itertuples" class="headerlink" title="itertuples"></a>itertuples</h3><p>For readers who are interested, this is the <a target="_blank" rel="noopener" href="https://github.com/pandas-dev/pandas/blob/v0.25.3/pandas/core/frame.py#L912">itertuples source code</a> for <code>itertuples</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arrays = []</span><br><span class="line">fields = <span class="built_in">list</span>(self.columns)</span><br><span class="line"><span class="keyword">if</span> index:</span><br><span class="line">    arrays.append(self.index)</span><br><span class="line">    fields.insert(<span class="number">0</span>, <span class="string">&quot;Index&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use integer indexing because of possible duplicate column names</span></span><br><span class="line">arrays.extend(self.iloc[:, k] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.columns)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3 supports at most 255 arguments to constructor</span></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">len</span>(self.columns) + index &lt; <span class="number">256</span>:</span><br><span class="line">    itertuple = collections.namedtuple(name, fields, rename=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(itertuple._make, <span class="built_in">zip</span>(*arrays))</span><br><span class="line"></span><br><span class="line"><span class="comment"># fallback to regular tuples</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">zip</span>(*arrays)</span><br></pre></td></tr></table></figure>

<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>For readers who are interested, this is the <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/functions.html#zip">zip source code</a> for python‚Äôs <code>zip</code> function</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zip</span>(<span class="params">*iterables</span>):</span><br><span class="line">    <span class="comment"># zip(&#x27;ABCD&#x27;, &#x27;xy&#x27;) --&gt; Ax By</span></span><br><span class="line">    sentinel = <span class="built_in">object</span>()</span><br><span class="line">    iterators = [<span class="built_in">iter</span>(it) <span class="keyword">for</span> it <span class="keyword">in</span> iterables]</span><br><span class="line">    <span class="keyword">while</span> iterators:</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> it <span class="keyword">in</span> iterators:</span><br><span class="line">            elem = <span class="built_in">next</span>(it, sentinel)</span><br><span class="line">            <span class="keyword">if</span> elem <span class="keyword">is</span> sentinel:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            result.append(elem)</span><br><span class="line">        <span class="keyword">yield</span> <span class="built_in">tuple</span>(result)</span><br></pre></td></tr></table></figure>

<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html">https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/52673285/performance-of-pandas-apply-vs-np-vectorize-to-create-new-column-from-existing-c">https://stackoverflow.com/questions/52673285/performance-of-pandas-apply-vs-np-vectorize-to-create-new-column-from-existing-c</a></li>
<li><a target="_blank" rel="noopener" href="https://towardsdatascience.com/how-to-make-your-pandas-loop-71-803-times-faster-805030df4f06">https://towardsdatascience.com/how-to-make-your-pandas-loop-71-803-times-faster-805030df4f06</a></li>
</ul>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data/" rel="tag">Data</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pandas/" rel="tag">Pandas</a></li></ul></div><div class="post-nav"><a class="pre" href="/2019/12/23/Another-way-to-better-organize-Pandas-code/">Another way to better organize Pandas code</a><a class="next" href="/2019/12/02/Build-your-own-blog-with-Hexo/">Build your own blog with Hexo</a></div><link rel="stylesheet" type="text/css" href="https://unpkg.com/disqusjs@1.3/dist/disqusjs.css"><script type="text/javascript" src="https://unpkg.com/disqusjs@1.3/dist/disqus.js"></script><script type="text/javascript" id="disqus-count-script">$(function() {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', '//disqus.com/next/config.json', true);
  xhr.timeout = 2500;
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 200) {
      $('.post-meta .post-comments-count').show();
      var s = document.createElement('script');
      s.id = 'dsq-count-scr';
      s.src = 'https://wei-xia-com.disqus.com/count.js';
      s.async = true;
      (document.head || document.body).appendChild(s);
    }
  };
  xhr.ontimeout = function () { xhr.abort(); };
  xhr.send(null);
});</script><div class="comments" id="disqus_thread"><script type="text/javascript">// Load comments with DisqusJS
function loadComments() {
  window.dsqjs = new DisqusJS({
    shortname: 'wei-xia-com',
    siteName: 'Wei\'s Sandbox',
    identifier: '2019/12/07/How-to-efficiently-loop-through-Pandas-DataFrame/',
    url: 'https://xiawei918.github.io/2019/12/07/How-to-efficiently-loop-through-Pandas-DataFrame/',
    title: 'How to efficiently loop through Pandas DataFrame',
    api: '',
    apikey: '',
    admin: '',
    adminLabel: ''
  });
}
// Lazy load {# Credit: https://github.com/theme-next/hexo-theme-next/blob/master/layout/_third-party/comments/disqus.swig #}
(function () {
  var offsetTop = document.getElementById('disqus_thread').offsetTop - window.innerHeight;
  if (offsetTop <= 0) {
    // Load directly when there's no scrollbar
    window.addEventListener('load', loadComments, false);
  } else {
    var disqusScroll = function () {
      // offsetTop may changes because of manually resizing browser window or lazy loading images
      var offsetTop = document.getElementById('disqus_thread').offsetTop - window.innerHeight;
      var scrollTop = window.scrollY;

      // Pre-load comments a bit? (margin or anything else)
      if (offsetTop - scrollTop < 60) {
        window.removeEventListener('scroll', disqusScroll);
        loadComments();
      }
    };
    window.addEventListener('scroll', disqusScroll);
  }
})();
// Scroll to comments automatically if #comment-xxx anchor specified
window.addEventListener('load', function () {
  // I don't know why, it just works.
  window.setTimeout(function () {
    if (location.hash.indexOf('#comment-') !== -1) {
      document.getElementById('disqus_thread').scrollIntoView(true);
    }
  }, 100);
}, false);
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://xiawei918.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about-me/" title="About"><img class="nofancybox" src="/img/head.jpg"/></a><p>ÊòéÂ§©ÊòØÂ§çÊùÇÁöÑÊº´Ê∏∏</p><a class="info-icon" href="mailto:xiawei91827149@gmail.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/xiawei918" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-alt" style="margin-inline:5px"></i></a><a class="info-icon" href="https://www.zhihu.com/people/xia-wei-16" title="Áü•‰πé" target="_blank" style="margin-inline:5px"> <i class="fa fa-graduation-cap" style="margin-inline:5px"></i></a><a class="info-icon" href="https://www.linkedin.com/in/weixia2/" title="Linkedin" target="_blank" style="margin-inline:5px"> <i class="fa fa-linkedin-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">ÁîüÊ¥ª</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Machine-Learning/" style="font-size: 15px;">Machine Learning</a> <a href="/tags/Linear-Regression/" style="font-size: 15px;">Linear Regression</a> <a href="/tags/Pandas/" style="font-size: 15px;">Pandas</a> <a href="/tags/Data/" style="font-size: 15px;">Data</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Optimization/" style="font-size: 15px;">Optimization</a> <a href="/tags/Dynamic-Programming/" style="font-size: 15px;">Dynamic Programming</a> <a href="/tags/Integer-Programming/" style="font-size: 15px;">Integer Programming</a> <a href="/tags/Programming/" style="font-size: 15px;">Programming</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Flask/" style="font-size: 15px;">Flask</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/07/03/deploy-flask-website-on-ec2-with-docker-compose2/">Deploy Flask Website On EC2 With Docker Compose [Part 2]</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/01/cycling/">‰ªéÈ™ëËΩ¶ÁúãÂç∑ÊñáÂåñ‰∏éÁªìÊûúÂØºÂêë</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/28/deploy-flask-website-on-ec2-with-docker-compose/">Deploy Flask Website On EC2 With Docker Compose [Part 1]</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/25/exploring-side-project-ideas/">Exploring Side Project Ideas</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/11/30/intro-to-linear-regression/">Introduction To Linear Regression: All You Need To Know About Linear Regression</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/19/Dynamic-program-vs-integer-program-which-one-is-better-for-knapsack-problem/">Dynamic program vs integer program: which one is better for knapsack problem?</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/23/Another-way-to-better-organize-Pandas-code/">Another way to better organize Pandas code</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/07/How-to-efficiently-loop-through-Pandas-DataFrame/">How to efficiently loop through Pandas DataFrame</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/Build-your-own-blog-with-Hexo/">Build your own blog with Hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/23/hello-world/">Welcome</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//wei-xia-com.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://lizic.com/" title="Cartesian Skepticism" target="_blank">Cartesian Skepticism</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright ¬© 2023 <a href="/." rel="nofollow">Wei's Sandbox.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>